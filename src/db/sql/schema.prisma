generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum TransactionType {
    IMPORT
    EXPORT
    ADJUST
}

model User {
    id           String          @id @default(uuid()) @db.Uuid
    email        String          @unique
    password     String
    username     String
    createdAt    DateTime        @default(now())
    updatedAt    DateTime        @updatedAt
    createdSlips PackagingSlip[] @relation("created_by")
    userRoles    UserRole[]
}

model Role {
    id          String     @id @default(uuid()) @db.Uuid
    name        String
    permissions String[]?
    description String?    @default("")
    createdAt   DateTime   @default(now())
    updatedAt   DateTime   @updatedAt
    userRoles   UserRole[]
}

model UserRole {
    user      User     @relation(fields: [userId], references: [id])
    userId    String   @db.Uuid
    role      Role     @relation(fields: [roleId], references: [id])
    roleId    String   @db.Uuid
    createdAt DateTime @default(now())

    @@id([userId, roleId])
}

model Warehouse {
    id         String               @id @default(uuid()) @db.Uuid
    name       String
    address    String
    createdAt  DateTime             @default(now())
    updatedAt  DateTime             @updatedAt
    stockItems PackagingStockItem[]
    slips      PackagingSlip[]
}

model Packaging {
    id         String               @id @default(uuid()) @db.Uuid
    name       String
    createdAt  DateTime             @default(now())
    updatedAt  DateTime             @updatedAt
    stockItems PackagingStockItem[]
}

model PackagingStockItem {
    id          String    @id @default(uuid()) @db.Uuid
    warehouse   Warehouse @relation(fields: [warehouseId], references: [id])
    warehouseId String    @db.Uuid
    packaging   Packaging @relation(fields: [packagingId], references: [id])
    packagingId String    @db.Uuid
    quantity    Int       @default(0)
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt

    transactions PackagingTransaction[]

    @@unique([warehouseId, packagingId], name: "unique_stock_per_warehouse_packaging")
    @@index([warehouseId])
}

model PackagingSlip {
    id          String          @id @default(uuid()) @db.Uuid
    code        String?         @unique
    type        TransactionType
    warehouse   Warehouse?      @relation(fields: [warehouseId], references: [id])
    warehouseId String?         @db.Uuid
    partnerId   String? // supplier/customer id if needed
    note        String?
    createdBy   User?           @relation("created_by", fields: [createdById], references: [id])
    createdById String?         @db.Uuid
    createdAt   DateTime        @default(now())
    updatedAt   DateTime        @updatedAt

    items PackagingTransaction[]

    @@index([warehouseId, createdAt])
}

model PackagingTransaction {
    id             String             @id @default(uuid()) @db.Uuid
    slip           PackagingSlip?     @relation(fields: [slipId], references: [id])
    slipId         String?            @db.Uuid
    stockItem      PackagingStockItem @relation(fields: [stockItemId], references: [id])
    stockItemId    String             @db.Uuid
    // KEEP quantity always positive at row-level, and store signedQuantity to represent +/- effect.
    quantity       Int // absolute amount
    signedQuantity Int // positive for IN, negative for OUT (computed at insert time)
    unitPrice      Float? // if you want costing
    createdAt      DateTime           @default(now())

    @@index([slipId])
    @@index([stockItemId])
    @@index([createdAt])
}
